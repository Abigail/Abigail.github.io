<html>
<head>
<title>Perl Weekly Challenge 118: Adventure of Knight</title>
<script src = "https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id = "MathJax-script" async src = "https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.js"></script>
<script src = '../../JavaScript/jquery.js'></script>
<script src = '../../JavaScript/navigation.js'></script>
<link rel = 'preconnect' href = 'https://fonts.gstatic.com'>
<link rel = 'stylesheet' href = 'https://fonts.googleapis.com/css2?family=Lobster+Two&family=Source+Code Pro&family=Pinyon+Script&family=Sorts+Mill Goudy:ital@1&display=swap'>
<link rel = 'stylesheet' href = '../../Styles/Perl-Weekly-Challenge/main.css'>
</head>

<body><h1>Perl Weekly Challenge 118: Adventure of Knight</h1><div class = "byline">
by Abigail<br>
<img src = "../../Images/jan_sluiters.jpg">
</div>


<h2><a href="https://perlweeklychallenge.org/blog/perl-weekly-challenge-118/#TASK2">Challenge</a></h2>

<blockquote>
  <p>A knight is restricted to move on an <code>8x8</code> chessboard. The knight is
  denoted by <code>N</code> and its way of movement is the same as what it is
  defined in Chess. <code>*</code> represents an empty square. <code>x</code> represents a
  square with treasure.</p>
  
  <blockquote>
    <p>The Knight's movement is unique. It may move two squares vertically
    and one square horizontally, or two squares horizontally and one
    square vertically (with both forming the shape of an L).</p>
  </blockquote>
  
  <p>There are 6 squares with treasures.</p>
  
  <p>Write a script to find the path such that Knight can capture all
  treasures. The Knight can start from the top-left square.</p>

<pre><code>      a b c d e f g h
    8 N * * * * * * * 8
    7 * * * * * * * * 7
    6 * * * * x * * * 6
    5 * * * * * * * * 5
    4 * * x * * * * * 4
    3 * x * * * * * * 3
    2 x x * * * * * * 2
    1 * x * * * * * * 1
      a b c d e f g h
</code></pre>
  
  <p><strong>BONUS: If you believe that your algorithm can output one of the
  shortest possible paths.</strong></p>
</blockquote>

<h2>Discussion</h2>

<div class = "section">
<p>There isn't much of a challenge here, is there?
<a href="https://en.wikipedia.org/wiki/Knight's_tour">Knight's tours</a>
have been known for eons. And a Knights tour visits every square on a
chess board. So, we could just pick one of the 19,591,828,170,979,904
different tours (sequence <a href="https://oeis.org/A165134">A165134</a> on the OEIS)
and call it a day. Or, if we wanted to return to our
starting square, we still have 26,534,728,821,064 closed tours to pick from.</p>

<p>And that's not even counting all the paths with visit a square more than
once &mdash; the challenge does not prohibit visiting a square more than once.</p>

<p>So, perhaps we should focus at the bonus part of the challenge.</p>

<p>But there isn't much of a challenge there. The problem is, there is no
variable input. There's just one input.</p>

<p>First, let us wonder the minimum length of a path capturing all 
the treasure. Of note is that if a chess knight is on a white
square, moving it lands it on a black square, and moving a knight
on a black square lands it on a white square. Now, a8, the square
the knight starts on, is white, and so are five of the squares 
containing treasure. This means, we need to take at least 10 steps 
to visit all the treasure.</p>

<p>Can we actually visit all the treasure in 10 steps? Well, after
10 steps, the knight is on a white square. Which means, a 10 step
path cannot finish on b2 (one of the squares containing treasure),
as b2 is a black square. Now look at the squares one knights move
away from b2: d1, d3, c4, and a4. Only one of them contains treasure
(c4). Which means that we either have to visit a white square not
containing treasure, or we visit a square containing treasure twice.
But to that, we need more than 10 steps.</p>

<p>So, what about an 11 step path. Is that possible?</p>

<p>Yes, it's easy to see there is an 11-step path visiting all the squares:</p>

<pre><code>a8 c7 e6 c5 b3 c1 a2 c3 b1 a3 c4 b2
</code></pre>

<p>So, an 11 step path is the shortest path possible.</p>

<p>But that means, there nothing left to be calculated, and the problem boils down
to a glorified <a href="https://en.wikipedia.org/wiki/"Hello,_World!"_program"><code>Hello, World!</code> program</a>.</p>
</div>

<h2>Solutions</h2>

<h3>Perl</h3>

<pre><code>say "a8 c7 e6 c5 b3 c1 a2 c3 b1 a3 c4 b2";
</code></pre>

<p>Find the <a href="https://github.com/Abigail/perlweeklychallenge-club/blob/master/challenge-118/abigail/perl/ch-2.pl">full program</a> on <a href="https://github.com">GitHub</a>.</p>

<h3>Other languages</h3>

<div class = "section">
<p>We also have solutions in <a href="https://github.com/Abigail/perlweeklychallenge-club/blob/master/challenge-118/abigail/awk/ch-2.awk">AWK</a>, <a href="https://github.com/Abigail/perlweeklychallenge-club/blob/master/challenge-118/abigail/bash/ch-2.sh">Bash</a>, <a href="https://github.com/Abigail/perlweeklychallenge-club/blob/master/challenge-118/abigail/basic/ch-2.bas">Basic</a>,
<a href="https://github.com/Abigail/perlweeklychallenge-club/blob/master/challenge-118/abigail/bc/ch-2.bc">bc</a>, <a href="https://github.com/Abigail/perlweeklychallenge-club/blob/master/challenge-118/abigail/befunge-93/ch-2.bf93">Befunge-93</a>, <a href="https://github.com/Abigail/perlweeklychallenge-club/blob/master/challenge-118/abigail/c/ch-2.c">C</a>, <a href="https://github.com/Abigail/perlweeklychallenge-club/blob/master/challenge-118/abigail/cobol/ch-2.cb">Cobol</a>, 
<a href="https://github.com/Abigail/perlweeklychallenge-club/blob/master/challenge-118/abigail/csh/ch-2.csh">Csh</a>, <a href="https://github.com/Abigail/perlweeklychallenge-club/blob/master/challenge-118/abigail/erlang/ch-2.erl">Erlang</a>, <a href="https://github.com/Abigail/perlweeklychallenge-club/blob/master/challenge-118/abigail/forth/ch-2.fs">Forth</a>, <a href="https://github.com/Abigail/perlweeklychallenge-club/blob/master/challenge-118/abigail/fortran/ch-2.f90">Fortran</a>, 
<a href="https://github.com/Abigail/perlweeklychallenge-club/blob/master/challenge-118/abigail/go/ch-2.go">Go</a>, <a href="https://github.com/Abigail/perlweeklychallenge-club/blob/master/challenge-118/abigail/java/ch-2.java">Java</a>, <a href="https://github.com/Abigail/perlweeklychallenge-club/blob/master/challenge-118/abigail/lua/ch-2.lua">Lua</a>, <a href="https://github.com/Abigail/perlweeklychallenge-club/blob/master/challenge-118/abigail/m4/ch-2.m4">m4</a>,
<a href="https://github.com/Abigail/perlweeklychallenge-club/blob/master/challenge-118/abigail/mmix/ch-2.mmix">MMIX</a>, <a href="https://github.com/Abigail/perlweeklychallenge-club/blob/master/challenge-118/abigail/node/ch-2.js">Node.js</a>, <a href="https://github.com/Abigail/perlweeklychallenge-club/blob/master/challenge-118/abigail/ocaml/ch-2.ml">OCaml</a>, <a href="https://github.com/Abigail/perlweeklychallenge-club/blob/master/challenge-118/abigail/pascal/ch-2.p">Pascal</a>, 
<a href="https://github.com/Abigail/perlweeklychallenge-club/blob/master/challenge-118/abigail/php/ch-2.php">PHP</a>, <a href="https://github.com/Abigail/perlweeklychallenge-club/blob/master/challenge-118/abigail/postscript/ch-2.ps">PostScript</a>, <a href="https://github.com/Abigail/perlweeklychallenge-club/blob/master/challenge-118/abigail/python/ch-2.py">Python</a>, <a href="https://github.com/Abigail/perlweeklychallenge-club/blob/master/challenge-118/abigail/r/ch-2.r">R</a>, 
<a href="https://github.com/Abigail/perlweeklychallenge-club/blob/master/challenge-118/abigail/rexx/ch-2.rexx">Rexx</a>, <a href="https://github.com/Abigail/perlweeklychallenge-club/blob/master/challenge-118/abigail/ruby/ch-2.rb">Ruby</a>, <a href="https://github.com/Abigail/perlweeklychallenge-club/blob/master/challenge-118/abigail/scheme/ch-2.scm">Scheme</a>, <a href="https://github.com/Abigail/perlweeklychallenge-club/blob/master/challenge-118/abigail/sed/ch-2.sed">sed</a>, 
<a href="https://github.com/Abigail/perlweeklychallenge-club/blob/master/challenge-118/abigail/sql/ch-2.sql">SQL</a>, and <a href="https://github.com/Abigail/perlweeklychallenge-club/blob/master/challenge-118/abigail/tcl/ch-2.tcl">Tcl</a>.</p>
</div>

<h2>Upping the ante</h2>

<div class = "section">
<p>Since the challenge as stated was not much of a challenge, we also
make an alternative solution &mdash; one which actually accepts input.</p>

<p>As input we take a line of input, where the squares containing
treasure are separated by white space. The first square is taken
as the start square of the knight.</p>
</div>

<h3>Perl</h3>

<p>We start off with a helper function, one which maps a tuple of a
rank and a file (both numbers from 1 to 8 inclusively), to the
algebraic name of the square:</p>

<pre><code>sub c2a ($file, $rank) {
    sprintf "%c%d", ord ('a') + $file - 1, $rank
}
</code></pre>

<p>Now, we precalculate all the possible knight moves. That is, for each
square, we calculate which squares are reachable with a single knights
move:</p>

<pre><code>my $MAX_FILE = 8;
my $MAX_RANK = 8;

my %knight_moves;  # Maps square to all squares reachable from it.
for my $file (1 .. $MAX_FILE) {
    for my $rank (1 .. $MAX_RANK) {
        my $square = c2a $file, $rank;
        #
        # Consider only moves in one direction; we add reverse moves as well.
        # Knight moves 2 in one direction, and 1 orthogonally from that.
        #
        for my $move ([1, 2], [1, -2], [2, 1], [2, -1]) {
            next unless 1 &lt;= $file + $$move [0] &lt;= $MAX_FILE &amp;&amp;
                        1 &lt;= $rank + $$move [1] &lt;= $MAX_RANK;
            my $target = c2a $file + $$move [0], $rank + $$move [1];
            push @{$knight_moves {$square}} =&gt; $target;
            push @{$knight_moves {$target}} =&gt; $square;
        }
    }
}
</code></pre>

<p>We now perform a <a href="https://en.wikipedia.org/wiki/Breadth-first_search">breadth first search</a>.</p>

<p>Now, normally in a breadth first search, we don't recurse once we
revisit a node. But in this challenge, it is possible the shortest
path visiting all treasure visits a square more than once. We will
recurse visiting a node we already visited, but only if we have a
visited a different set of squares with treasure. (Alternatively,
we could consider finding a path where the nodes are the 
<a href="https://en.wikipedia.org/wiki/Cartesian_product">cartesian product</a> of the squares on
the board, and the <a href="https://en.wikipedia.org/wiki/power_set">power set</a> of the set of
treasure squares).</p>

<p>For the breadth first search, we keep a <code>@todo</code> array, where each
element is tuple (representing a node in the graph we're searching):
the first element is the path that got us there (with the last
element being the current square). The second element is a hash
where the keys are the treasure squares we have visited on the path
in the first element.</p>

<p>In the main loop, we shift an element from the <code>@todo</code> list, calculate
which squares are reachable, and for each of those squares, we push
a new element to the <code>@todo</code> array. If we have seen all the treasure,
we return the current path:</p>

<pre><code>sub find_treasure ($start_square, @treasure) {
    my %treasure = map {$_ =&gt; 1} @treasure;

    my %visited;
    my @todo = ([[$start_square], {}]);

    while (@todo) {
        my ($path, $old_seen) = @{shift @todo};
        my  $square = $$path [-1];
        my  $seen = { %$old_seen};
           $$seen {$square} = 1 if $treasure {$square};

        my $key = join " " =&gt; $square, sort keys %$seen;
        next if $visited {$key} ++;

        if (keys %$seen == keys %treasure) {
            return $path;
        }   

        push @todo =&gt; map {[[@$path =&gt; $_], $seen]} @{$knight_moves {$square}};
    }
}
</code></pre>

<p>All what rest is read in the input, call the method above, and
print the result. We can do that in a one liner:</p>

<pre><code>say "@{find_treasure split}" while &lt;&gt;;
</code></pre>

<p>Find the <a href="https://github.com/Abigail/perlweeklychallenge-club/blob/master/challenge-118/abigail/perl/ch-2a.pl">full program</a> on GitHub.</p>

<hr id = 'last-line'>
<div class = 'trailer'>
<p class = 'prev'><a class = "prev" href = "">&#x261C;</a></p>
<p class = 'issue'>Please leave any comments as a
  <a href = 'https://github.com/Abigail/Abigail.github.io/issues'
     title = 'GitHub issue'>GitHub issue</a>.
<p class = 'next'><a class = "next" href = "">&#x261E;</a></p>
</div>

</body>
</html>
