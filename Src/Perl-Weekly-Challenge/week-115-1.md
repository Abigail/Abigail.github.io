# Perl Weekly Challenge 115: String Chain

## [Challenge](https://perlweeklychallenge.org/blog/perl-weekly-challenge-115/#TASK1)

> You are given an array of strings.
>
> Write a script to find out if the given strings can be chained to form
> a circle. Print `1` if found otherwise `0`.
>
> A string `$S` can be put before another string `$T` in circle if the
> last character of `$S` is same as first character of `$T`.

### Examples

>     Input: @S = ("abc", "dea", "cd")
>     Output: 1

Since we can form a circle, e.g. `"abc"`, `"cd"`, `"dea"`.

>     Input: @S = ("ade", "cbd", "fgh")
>     Output: 0

We cannot form a circle.


## Discussion

It is not clear whether the question is whether we can for a cycle
(we opt to use the term [cycle](#wiki:Cycle_(graph_theory)) instead
of circle here, as this is a more common term in this context).
making use of all the strings, or whether any cycle is ok, even
if it does not include all the strings. The examples are useless in
that respect, as one example forms a cycle with all the strings, and
the latter doesn't have any cycle.

We opt for the latter interpretation here, that is, we're looking
for any cycle. The former interpretation is equivalent to finding
a [Eulerian Cycle](#wiki:Eulerian_path).

## Solution

We can turn the challenge into a graph problem. Let
\(\mathcal{G} = (V, E)\) be a directed graph where the set of
vertices \(V\) is defined by the beginning and end characters
of the given strings. For each of the given strings, there
will be a directed edge in the set of edges \(E\): an edge
from the beginning character to the end character of the strings.

So, for the first example, we get \(V = (a, c, d)\) and
\(E = (\langle a, c\rangle, \langle d, a\rangle, \langle c, d\rangle)\).
Note since \(\mathcal{G}\) is a directed graph, the direction of
the edges matter: \(\langle a, b \rangle\) is a different edge
than \(\langle b, a \rangle\).

To determine whether the graph contains a cycle, we will calculate
the [*transitive closure*](#wiki:Transitive_closure#In_graph_theory)
of the graph. The transitive closure of a graph
\(\mathcal{G} = (V, E)\) is \(\mathcal{G}^T = (V, E^T)\), where
\(\langle v_1, v_2 \rangle \in E^T \iff v_1 \in V \wedge v_2 \in V \wedge\)
there is a path from \(v_1\) to \(v_2\) in \(\mathcal{G}\).
A graph \(\mathcal{G}\) contains a cycle, iff the set
\(\\{v \in V | \langle v, v \rangle \in E^T\\}\) is not empty. That is,
the transitive closure has at least one edge with the same begin and
end point.

To calculate the transitive closure, we make use of a simplified
[Floyd-Warshall algorithm](#wiki). This algorithm is used to calculate
the length all the shortest paths between any pair of vertices in a
graph. However, for the transitive closure, all we care about is that
the shortest path isn't \(\infty\). 

The algorithm takes a graph as a [adjacency matrix](#wiki) as input. 
That is, `matrix [x] [y]` is true of the graph has a directed edge
between `x` and `y`, and false otherwise.

In pseudo code, the algorithm is as follows (`V` is the set of vertices
of the graph, `matrix` is the adjacency matrix of the graph):
~~~~
for k in V
do  for i in V
    do  for j in V
        do  matrix [i] [j] = true if matrix [i] [k] and matrix [k] [j]
        done
    done
done
~~~~
At the end of the procedure, we're left with the transitive closure
in `matrix`.

It is easy to see that the running time of this algorithm is
\(\Theta(|V|^3)\). For some cases, this may not be optimal;
running Dijkstra's algorithm for each vertex takes
\(\mathcal{O} (|E||V| + |V|^2 \log |V|)\), which is better
than \(\Theta(|V|^3)\) if \(|E| \ll |V|^2\). However,
Floyd-Warshall is really easy to implement, and if the strings
are ASCII strings, \(|V|\) is small. So, we go with Floyd-Warshall.

### Perl

There is a module on [CPAN](https://www.cpan.org/)
which calculates the transitive closure,
[`Algorithm::Graphs::TransitiveClosure`](#), and it uses the
Floyd Warshall algorithm. Normally, I wouldn't use a CPAN module
doing all or most of the task, except when I authored the module.
And I did write and upload `Algorithm::Graphs::TransitiveClosure`
to CPAN back in 1998.

So, all what is needed to do is to read the input and create an adjacency
matrix:
~~~~
foreach my $node (split) {
    $$graph {substr $node, 0, 1} {substr $node, -1} = 1;
}
~~~~
call the algorithm (which modifies the given matrix):
~~~~
use Algorithm::Graphs::TransitiveClosure qw [floyd_warshall];
floyd_warshall $graph;
~~~~
and check for cycles:
~~~~
say grep ({$$graph {$_} {$_}} keys %$graph) ? 1 : 0;
~~~~

FULL_PROGRAM
