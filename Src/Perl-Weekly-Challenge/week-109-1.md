# Perl Weekly Challenge 109: Chowla Numbers

## [Challenge](https://perlweeklychallenge.org/blog/perl-weekly-challenge-109/#TASK1)

> Write a script to generate first 20 Chowla Numbers, named after,
> Sarvadaman D. S. Chowla, a London born Indian American mathematician.
> It is defined as:
>
>     C(n) = sum of divisors of n except 1 and n

### Output
~~~~
0, 0, 0, 2, 0, 5, 0, 6, 3, 7, 0, 15, 0, 9, 8, 14, 0, 20, 0, 21
~~~~

## Discussion
Another glorified [`Hello, World!`](#wiki:Hello_World) program!

Just like in [last weeks challenge](week-108-2.html), we have
three options to solve this:

1. Just print the 20 required numbers, as given in the challenge.
2. Fetch the [right sequence](#oeis:48050) from the [OEIS](https://oeis.org),
   extract the first 20 numbers, and print those.
3. Calculate the numbers.

In all the languages we provide solutions in, we at least implement
the first strategy. For Perl, we also implement the second strategy.
And for a handful of languages, we also implement the last
strategy.

The solutions implementing multiple strategies take command line
argument, indiciting which strategy to use. This argument is one
off: `plain` (for the first strategy), `fetch` (for the second
strategy), or `compute` (for the third). If no argument is given,
an argument which isn't recognized, or one which isn't implemented,
the solution falls back to the first strategy.

## Solutions

We will only discuss solutions implementing the third strategy;
that is, actually computing the numbers. 

Summing the divisors of a number \(N\) is at least as hard
as factorizing \(N\), which is a
[hard problem](https://en.wikipedia.org/wiki/Integer_factorization).

For non-quantum computers, as of this writing, the
[best know algorithm](https://doi.org/10.1007/BFb0091539) takes

\[ \exp\left( \left(\sqrt[3]{\frac{64}{9}} + \mathcal{o} (1)\right)
            (\ln N)^{\frac{1}{3}}(\ln \ln N)^{\frac{2}{3}}\right) \]

time to factor a number \(N\), using a 
[general number field sieve](#wiki:General_number_field_sieve).

(For quantum computers, [Shor's algorithm](#wiki:Shor's_algorithm)
can factor a number \(N\) in \(\mathcal{O} \left((\ln N)^3\right)\) time,
using \(\mathcal{O} \left((\ln N)^2(\ln \ln N)(\ln \ln \ln N)\right)\)
[quantum gates](#wiki).)

Luckily, we don't have to do anything hard. No deep math, nor a quantum
computer. After all, we don't have to solve the general case, we only
have compute the Chowla Number for a handful of tiny integers.

So, for a number \(N\), we just check all numbers \(k: 1 < k \leq \frac{N}{2}\)
to see if they evenly divide \(N\), and sum those that do. That's
only 81 modulo operations.

### Perl
~~~~
my $COUNT = 20;
use List::Util qw [sum0];
$, = ", ";
say map {my $n = $_; sum0 grep {!($n % $_)} 2 .. $_ / 2} 1 .. $COUNT;
~~~~

Here the [`map`](#) takes each number from `1` to `20`, and calculates
the Chowla Number for it. To do so, given a number `$n`, we [`grep`](#) the
numbers which evenly divide `$n` (by checking if the modulo is 0).
The `grep` returns a, possibly empty, list, which we sum using `sum0`
from the [`List::Util`](#) module. `sum0` returns `0` when summing
an empty list.

FULL_PROGRAM

### Bash

We first create a method `divisor_sum` which sums the proper divisors
(except `1`) of its argument. A simple loop starting from `2`, and
ending at half the functions argument.

~~~~
function divisor_sum () {
    local n=$1
    sum=0
    local i
    for ((i = 2; i <= n / 2; i ++))
    do  if   ((n % i == 0))
        then ((sum += i))
        fi
    done
}
~~~~

Und jezts...

~~~~
for ((n = 1; n <= COUNT; n ++))
do  if   ((n > 1))
    then printf ", "
    fi
    divisor_sum $n
    printf $sum
done
echo ""
~~~~
