# Perl Weekly Challenge 135: Middle 3-digits

## [Challenge][task1]
>>>>
You are given an integer.

Write a script find out the middle 3-digits of the given integer,
if possible otherwise throw sensible error.
<<<<

### Example 1

~~~~
Input: $n = 1234567
Output: 345
~~~~

### Example 2

~~~~
Input: $n = -123
Output: 123
~~~~

### Example 3

~~~~
Input: $n = 1
Output: too short
~~~~

### Example 4

~~~~
Input: $n = 10
Output: even number of digits
~~~~

[task1]: https://theweeklychallenge.org/blog/perl-weekly-challenge-135/#TASK1

## Solution

We need to do a couple of things, all fairly trivial:

1. Read a line from standard input.
2. Remove a leading sign, as we can basically ignore it.
3. Check we're left with only digits; error if not.
4. Check we have an odd number of digits; error if not.
5. Check we have at least three digits; error if not.
6. Extract the middle three digits, and print them.

The third step technically isn't required, as it's a given we're getting
an integer. But we check anyway.

Note that a two digit integer fails validation twice: it's too short,
and it has an even number of digits. The fourth example shows we should
give an error for the second failure (and not the first).

As usual, we will be accepting multiple integers, assuming one
integer per line of input. For each integer, we'll print the
middle three digits, or an error if necessary.

### AWK

AWK is very suitable to repeatedly do something to a line of input,
and to repeat this for each line of input.

We start off with stripping a leading sign, if any:

~~~~
/^[-+]/         {$0 = substr ($0, 2)}
~~~~

`$0` holds the current line of input, and it's an lvalue, so we can
assign to it.

We can now do the validation. If it fails a validation, we print an
error message, and continue with the next line of input:

~~~~
/[^0-9]/        {print "not an integer";        next}
/^(..)*$/       {print "even number of digits"; next}
length ($0) < 3 {print "too short";             next}
~~~~

We can now print the middle three digits:

~~~~
{print substr ($0, 1 + (length ($0) - 3) / 2, 3)}
~~~~

[`substr`](#) in AWK takes three arguments: the string we want to
extract a substring from; the position from where to start (first
character is on position 1), and the length of the substring.

FULL_PROGRAM

### Bash

We first start off reading a line of input using [`read`](#):

~~~~
while read line; do
~~~~

First, we strip off a leading sign, if any, using
[parameter expansion](#Shell-Parameter-Expansion):

~~~~
line=${line/#[-+]/}
~~~~

This takes what is in the variable `line`, and performs a substitution:
replacing `#[-+]` with nothing (because there is nothing following
the second slash. Where most languages use `^` to indicate the
beginning of a string, here, this role is played by `#`.

We now check whether we are left with just digits:

~~~~
if [[ $line =~ [^0-9] ]]
then echo "not an integer"
~~~~

[`[[`](#Bash-Conditional-Expressions) introduces *Bash Conditional
Expressions*. The expression results in a true/false result. Here,
we are matching `line` against a regular expression. Note that we
don't need a delimiter here.

Checking for the right amount of digits:

~~~~
elif ((${#line} % 2 == 0))
then echo "even number of digits"
elif ((${#line} < 3))
then echo "too short"
~~~~

[`((`](#Shell-Arithmetic) introduces *Shell Arithmetic*.

If we have passed all validations, we can print the right substring:

~~~~
echo ${line:$(((${#line} - 3) / 2)):3}
~~~~

We do this with several other
[parameter expansions](#Shell-Parameter-Expansion).

`${#line}` is the first parameter expansion. The result is the length
of the string in `line`.

`$(((${#line} - 3) / 2))` takes what is inside `$(( ))` and treats
it as an arithmetic expression. The result is the start index of
substring we want.

We use another type of parameter expansion to get the substring:
`${line:position:length}` gets `length` characters from `line`,
starting at position `position`.

FULL_PROGRAM

### C

We start off with reading a line from standard input. [`getline`](#)
will do the job:

~~~~
char *  line    = NULL;
size_t  len     = 0;
size_t  str_len;
while ((str_len = getline (&line, &len, stdin)) != -1) {
~~~~

The string (with terminating newline) will be put into the character
array `line`, while the return value of `getline` is the length
of the line. (`getline` will do the [`malloc`](#)ing for us, and
populate `len` with the number of bytes allocated; we will not
use `len` in our program).

We start with removing a leading sign, if any (if there is any
space following the sign, we will remove this as well):

~~~~
char * line_ptr = line;
if (* line_ptr == '-' || * line_ptr == '+') {
    str_len --;
    line_ptr ++;
    while (isspace (* line_ptr)) {
        line_ptr ++;
        str_len --;
    }
}
~~~~

The result is that afterwards, `line_ptr` will point to the first
character following the sign. 

Next step is to make sure all the other characters are digits.
Note that our string still contains a newline:

~~~~
bool done = false;
char * line_ptr2 = line_ptr;
while (* line_ptr2 && * line_ptr2 != '\n') {
    if (!isdigit (* line_ptr2)) {
        printf ("not an integer\n");
        done = true;
        break;
    }
    line_ptr2 ++;
}
if (done) {
    continue;
}
~~~~

C cannot break out of nested loops, so we determine the input
contains a non-digit, we set a boolean, and do the 
`continue` after we're done with the inner loop.

We can now check we have the right amount of digits (while
remembering we have a trailing newline):

~~~~
if (str_len % 2 == 1) {
    printf ("even number of digits\n");
    continue;
}

if (str_len < 4) {
    printf ("too short\n");
    continue;
}
~~~~

We can print the middle three digits, which we print one by one,
followed by a newline:

~~~~
size_t mid = (str_len - 3) / 2;
for (size_t i = 0; i < 3; i ++) {
    printf ("%c", line_ptr [mid + i]);
}
printf ("\n");
~~~~

It's C, so, we shouldn't forget the [`free`](#) allocated
memory:

~~~~
free (line);
~~~~

FULL_PROGRAM

### Go

First, we have to read a line from standard input:

~~~~
    var reader = bufio . NewReader (os. Stdin)
main_loop:
    for {
        var text, err = reader . ReadString ('\n')
        if (err != nil) {
            break
        }
~~~~

Stripping off the newline we do with [`TrimRight`](#) in the `string`
module:

~~~~
text = strings . TrimRight (text, "\n")
~~~~

Go has immutable strings, so we have a leading sign, we take a
[*slice*](https://go.dev/blog/slices-intro)
from the string, and assign that back to the string:

~~~~
if (text [0:1] == "-" || text [0:1] == "+") {
    text = text [1:]
}
~~~~

We now check whether the string contains just digits. For that,
we iterate over the [*runes*](https://go.dev/blog/strings) of the string:

~~~~
for _, rune := range text {
    if rune < '0' || rune > '9' {
        fmt . Print ("not an integer\n")
        continue main_loop
    }
}
~~~~

We can now check for the correct number of digits. 
[`len`](#) returns the length of a string:

~~~~
if len (text) % 2 == 0 {
    fmt . Print ("even number of digits\n")
    continue main_loop
}

if len (text) < 3 {
    fmt . Print ("too short\n")
    continue main_loop
}
~~~~

Now we can print the required digits, using a slice:

~~~~
fmt . Printf ("%s\n", text [(len (text) - 3) / 2 :
                            (len (text) + 3) / 2])
~~~~

FULL_PROGRAM

### Java

Java requires even more work to be done to just read a line of input:

~~~~
Scanner scanner = new Scanner (System . in);
try {
    while (true) {
        String line = scanner . nextLine ();
~~~~

This time, we first check whether we have an integer, by using a regular
expression. The
[`matches`](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html#matches(java.lang.String,%20java.lang.CharSequence))
function in the `Pattern` class
tries to match the given pattern against the given string:

~~~~
if (!Pattern . matches ("^[-+]?[0-9]+$", line)) {
    System . out . println ("not an integer");
    continue;
}
~~~~

If the string starts with a sign, we get rid of it. Java strings
are immutable, so we take a substring and assign it back to the
string:

~~~~
if (Pattern . matches ("^[-+].*", line)) {
    line = line . substring (1);
}
~~~~

We can now check for the right amount of digits:

~~~~
int ll = line . length ();
if (ll % 2 == 0) {
    System . out . println ("even number of digits");
    continue;
}
if (ll < 3) {
    System . out . println ("too short");
    continue;
}
~~~~

Finally, we print the wanted digits:

~~~~
System . out . println (line . substring ((ll - 3) / 2,
                                         (ll + 3) / 2));
~~~~

FULL_PROGRAM

### Node.js

First, we strip off the sign and the trailing newline. `line` contains
a line from standard input:

~~~~
line . replace (/^[-+]/, '') . trim ()
~~~~

[`replace`](#) takes two arguments, a pattern, and a replacement,
while [`trim`](#) removes whitespace from either end of the string.
Neither method changes a string -- they return the modified string.

We now do the validations as a sequence of `if/else` statements:

~~~~
if (line . match (/[^0-9]/)) {
    console . log ("not an integer")
}
else {
    if (line . length % 2 == 0) {
        console . log ("even number of digits")
    }
    else {
        if (line . length < 3) {
            console . log ("too short")
        }
    }
}
~~~~

[`match`](#) 
