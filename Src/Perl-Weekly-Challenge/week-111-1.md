# Perl Weekly Challenge 111: Search Matrix

## [Challenge](https://perlweeklychallenge.org/blog/perl-weekly-challenge-111/#TASK1)

> You are given 5x5 matrix filled with integers such that each row is
> sorted from left to right and the first integer of each row is greater
> than the last integer of the previous row.
>
> Write a script to find a given integer in the matrix using an
> efficient search algorithm.

### Example

>     Matrix: [  1,  2,  3,  5,  7 ]
>             [  9, 11, 15, 19, 20 ]
>             [ 23, 24, 25, 29, 31 ]
>             [ 32, 33, 39, 40, 42 ]
>             [ 45, 47, 48, 49, 50 ]
> 
>     Input: 35
>     Output: 0 since it is missing in the matrix
> 
>     Input: 39
>     Output: 1 as it exists in the matrix

## Discussion

This challenge confuses me. We're basically asked to find a number
in a sorted list. Which in languages without hashes one would solve
with binary search (yielding an \(\mathcal{O} (\log N)\) solution),
and in languages with hashes you'd use a hash (yielding an \(\mathcal{O} (1)\)
(expected) time solution).
Sure, the hash takes linear preprocessing time, but since we're asked
to write a script, we're spending linear time reading in the data
anyway.

Perhaps the intend was a subroutine which takes a matrix and a target
number, but that was not what is being asked. The challenge explicitly
asks for *a script*, which means we have to spend a linear amount of
time reading data anyway. So, that's what you get.

The only part where we use the fact we are given a matrix is for the
input: the first five lines are assumed to contain the matrix. The
rest of the input is taken as numbers to search for.

Only for language lacking hashes/maps/dictionaries/tables, we will
make use of the fact the input is sorted. For the majority of
languages, the fact input is sorted does not offer additional benefits.

## Solutions

All the solutions first read the matrix (five rows with five integers,
separated by white space) from standard input. The rest of the input
is taken as numbers to search for -- one integer per line.

### Perl

For our Perl solution, we offer two ways to solve this.

First is a simple hash based solution:
~~~~
my $MATRIX_SIZE = 5;
my %matrix;
@matrix {<> =~ /-?[0-9]+/g} = () for 1 .. $MATRIX_SIZE;

chomp, say exists $matrix {$_} || 0 while <>;
~~~~
Here, we read in five lines of data, which we store in a hash.
Then for the rest of the input, we print `1` or `0` depending
on whether the number is in the matrix or not.

Our second solution has a subroutine which takes two arguments:
a 5 x 5 matrix (a reference to a two dimensional array), and 
a number to search for. We're using a bog standard binary search
to find the number. Binary search uses a one dimensional structure
to search, but we can trivially map a one dimensional coordinate to
a two dimensional one by using integer division, and the modulus operation.
~~~~
my sub bsearch ($matrix, $target) {
    my ($min, $max) = (0, $MATRIX_SIZE * $MATRIX_SIZE);
    while ($min < $max) {
        use integer;
        my $mid = ($min + $max) / 2;
        #
        # To map a 1-d coordinate c to a 2-d pair x, y, we use
        # x = floor (c / size), y = c % size.
        #
        my $cmp = $$matrix [$mid / $MATRIX_SIZE]
                           [$mid % $MATRIX_SIZE] <=> $target;
        if    ($cmp < 0) {$min = $mid + 1}
        elsif ($cmp > 0) {$max = $mid}
        else  {return 1}
    }
    return (0)
}
~~~~

FULL_PROGRAM

