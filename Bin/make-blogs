#!/opt/perl/bin/perl

use 5.028;

use strict;
use warnings;
no  warnings 'syntax';

use experimental 'signatures';
use experimental 'lexical_subs';

use Text::Markdown qw [markdown];

my $POLYFILL_URL  = "https://polyfill.io/v3/polyfill.min.js?features=es6";
my $MATHJAX_URL   = "https://cdn.jsdelivr.net/npm/mathjax@3/" .
                            "es5/tex-mml-chtml.js";

my $HOME           = $ENV {HOME};
my $TOP_DIR        = "$HOME/GitHub/Blogs";
my $SRC_DIR        = "Src";
my $HTML_DIR       = "HTML";
my $PWC_DIR        = "Perl-Weekly-Challenge";
my $STYLE_DIR      = "Styles";
my $JAVASCRIPT_DIR = "JavaScript";
my @SCRIPTS        = qw [jquery navigation];
my $FULL_HTML_DIR  = "$TOP_DIR/$HTML_DIR";
my $FULL_SRC_DIR   = "$TOP_DIR/$SRC_DIR";
my @FONTS          = map {s/ /+/r} ("Lobster Two",
                                    "Source Code Pro",
                                    "Pinyon Script",
                                    'Sorts Mill Goudy:ital@1',);
my $FONTS          = join "&" => map {"family=$_"} @FONTS;
my $FONT_URL       = "https://fonts.googleapis.com/css2?$FONTS&display=swap";

my $PERLFUNC_URL   = "https://perldoc.perl.org/perlfunc";
my $METACPAN_URL   = "https://metacpan.org/pod";
my $GAWK_URL       = "https://www.gnu.org/software/gawk/manual/gawk.html";
my $FREEBSD_URL    = "https://www.freebsd.org/cgi/man.cgi?" .
                                                 "apropos=0&sektion=0&query";
my $WIKI_URL       = "https://en.wikipedia.org/wiki";
my $OEIS_URL       = "https://oeis.org";

my $GITHUB_URL     = "https://github.com";
my $GITHUB_USER    = "Abigail";
my $GITHUB_REPO    = "perlweeklychallenge-club";
my $GITHUB_BRANCH  = "master";
my $CHALLENGE_USER = "abigail";

my %LANGUAGE_INFO = (
    AWK         => {},
   "GNU AWK"    => {name => "awk",  ext => "gawk"},
    Bash        => {                ext =>   "sh"},
    Basic       => {                ext =>  "bas"},
    bc          => {},
   "Befunge-93" => {                ext => "bf93"},
    C           => {},
    Cobol       => {                ext =>   "cb"},
    Csh         => {                ext =>  "csh"},
    Erlang      => {                ext =>  "erl"},
    Forth       => {                ext =>   "fs"},
    Fortran     => {                ext =>  "f90"},
    Go          => {},
    Java        => {},
    Lua         => {},
    m4          => {},
   "Node.js"    => {name => "node", ext =>   "js"},
    OCaml       => {                ext =>   "ml"},
    Pascal      => {                ext =>    "p"},
    Perl        => {                ext =>   "pl"},
    PHP         => {},
    PostScript  => {                ext  =>  "ps"},
    Python      => {                ext =>   "py"},
    R           => {},
    Rexx        => {},
    Ruby        => {                ext =>   "rb"},
    Scheme      => {                ext =>  "scm"},
    sed         => {},
    SQL         => {},
    Tcl         => {},
);

chdir $TOP_DIR or die "chdir: $!";


sub header ($title, $week) {
    #
    # Return the header of the HTML page
    #

    my $styles = join "\n" =>
        map  {"<link rel = 'stylesheet' href = '../../$_'>"}
        grep {-f}
        map  {"$STYLE_DIR/$_.css"} "main",
                        "$PWC_DIR/main",
                        "$PWC_DIR/week-$week";

    my $scripts = join "\n" =>
        map {"<script src = '../../$JAVASCRIPT_DIR/$_.js'></script>"}
             @SCRIPTS;

    return <<~ "--";
        <head>
        <title>$title</title>
        <script src = "$POLYFILL_URL"></script>
        <script id = "MathJax-script" async src = "$MATHJAX_URL"></script>
        $scripts
        <link rel = 'preconnect' href = 'https://fonts.gstatic.com'>
        <link rel = 'stylesheet' href = '$FONT_URL'>
        $styles
        </head>
        --
}

#
# Create a link to the full program on GitHub
#
sub github_link ($language, $week) {
    my ($week_nr, $part_nr) = split /-/ => $week;
    my $lang_info = $LANGUAGE_INFO {$language};
    my $link = sprintf "%s/%s/%s/blob/%s/challenge-%03d/%s/%s/ch-%d.%s" =>
                        $GITHUB_URL,
                        $GITHUB_USER,
                        $GITHUB_REPO,
                        $GITHUB_BRANCH,
                        $week_nr,
                        $CHALLENGE_USER,
                        $$lang_info {name} || lc $language,
                        $part_nr,
                        $$lang_info {ext}  || lc $language;
    $link;
}

sub full_program ($language, $week) {
    my $link = github_link ($language, $week);
    return "Find the [full program]($link) on [GitHub]($GITHUB_URL).\n";
}



#
# For patterns of the form [...](#...), this method is called,
# and the result is substituted will be placed inside the ().
#
sub make_link (%args) {
    my $anchor   = $args {anchor};
    my $link     = $args {link};
    my $week     = $args {week};
    my $language = $args {language};
    my $url;
    if ($LANGUAGE_INFO {$language}) {
        # Remove backtics
        $anchor =~ s/^`//;
        $anchor =~ s/`$//;
        if ($language eq "Perl") {
            if (!$link) {
                #
                # Does the link point to a module?
                #
                $url = $anchor =~ /::/ ? $METACPAN_URL . "/" . $anchor
                                       : $PERLFUNC_URL . "#" . $anchor;
            }
        }
        elsif ($language eq "GNU AWK" || $language eq "AWK") {
            $url = $GAWK_URL . "#" . $link;
        }
        elsif ($language eq "C") {
            if (!$link) {
                $url = $FREEBSD_URL . "=" . $anchor;
            }
        }
    }
    if (!$url) {
        if ($link =~ /(?<where>[^:]+):(?<what>.*)/) {
            my $where = $+ {where};
            my $what  = $+ {what};
            if    ($where eq "wiki") {$url = $WIKI_URL . "/" . $what}
            elsif ($where eq "oeis") {$url = $OEIS_URL . "/" . $what}
        }
        elsif ($link eq "github") {
            $url = github_link ($anchor, $week);
        }
    }
    $url //= "#$link";

    $url;
}

my $link_pattern = qr {\[    (?<anchor> [^]]*) \]
                       \( \# (?<link>   [^)]*) \)}x;

sub process_section ($section, $language, $week) {
    #
    # Step one, find the links starting with a #, and process them.
    #
    $section =~ s {$link_pattern}
                  {"[" . $+ {anchor} . "]" .
                   "(" . make_link (anchor   => $+ {anchor},
                                    link     => $+ {link},
                                    week     => $week,
                                    language => $language) . ")"}ge;

    #
    # Replace any lines with FULL_PROGRAM to a section pointing
    # to the file on GitHub.
    #
    $section =~ s {^FULL_PROGRAM\s*$} {full_program ($language, $week)}gem;

    #
    # Process MathJax delimiters
    #
    $section =~ s/(?<!\\)(\\[]()[])/\\$1/g;

    #
    # Turn a double dash into an &mdash;
    #
    $section =~ s/(?<!-)--(?!-)/&mdash;/g;

    $section . "\n";
}



sub pre_process ($text, $week) {
    state $lang_pat = join "|" => map {quotemeta $_} keys %LANGUAGE_INFO;

    my $out = "";

    #
    # Iterate over the lines. Use states to determine whether we're
    # inside a preformatted block (toggle on ~~~~), and what the current
    # language is (### <LANG>).
    #
    my $language     = "";
    my $preformatted =  0;
    my $section      = "";

    foreach my $line (split /\n/ => $text) {
        $preformatted = !$preformatted, next if $line eq "~~~~";
        if ($preformatted) {
            if ($section) {
                $out .= process_section ($section, $language, $week);
                $section = "";
            }
            $out .= "    $line\n";
            next;
        }
        if ($line =~ /^###\s*(?<header>.*)/) {
            if ($section) {
                $out .= process_section ($section, $language, $week);
                $section = "";
            }
            $language = $+ {header};
            $out .= $line . "\n";
            next;
        }
        $section .= $line . "\n";
    }
    if ($section) {
        $out .= process_section ($section, $language, $week);
    }

    return $out;
}


sub by_line {<<~ "--"}
    <div class = "byline">
    by Abigail<br>
    <img src = "../../Images/jan_sluiters.jpg">
    </div>
    --

sub post_process ($text) {
    #
    # Add a line after the first <h1>
    #
    $text =~ s{</h1>.*\K}{by_line}e;

    #
    # Turn sections between headers into divs
    #
    $text =~ s {(</h[1-6]>\s*)(<p>.*?\S)(\s*(?:<h[1-6]>|</body>))}
               {$1<div class = "section">\n$2</div>$3}gs;
    $text;
}

sub trailer ($week) {<<~ "--"}
    <hr id = 'last-line'>
    <div class = 'trailer'>
    <p class = 'prev'><a class = "prev" href = "">&#x261C;</a></p>
    <p class = 'issue'>Please leave any comments as a
      <a href = 'https://github.com/Abigail/Abigail.github.io/issues'
         title = 'GitHub issue'>GitHub issue</a>.
    <p class = 'next'><a class = "next" href = "">&#x261E;</a></p>
    </div>
    --

#
# For now, we just handle Perl Weekly Challenges
#
my @sources =
   @ARGV ? map {/^[0-9]{3}-[0-9]$/ ? "$SRC_DIR/$PWC_DIR/week-$_.md"
                                   :  $_} @ARGV
         : `find $SRC_DIR -name "*.md"`;

chomp (@sources);

foreach my $source_file (@sources) {
    my $html_file = $source_file =~ s/^$SRC_DIR/$HTML_DIR/r
                                 =~ s/\.md$/.html/r;
    my ($week)    = $source_file =~ m{.*/week-(.*)\.md};
    next if !@ARGV && -f $html_file && (stat $html_file)   [9] >
                                       (stat $source_file) [9]; # 9: mtime

    my $source_text = `cat $source_file`;

    $source_text = pre_process $source_text, $week;

    my $html_text   = markdown ($source_text => {
        empty_element_suffix => ">"
    });
    $html_text = "<body>$html_text</body>";

    $html_text = post_process ($html_text);

    my ($title) = $html_text =~ m{<h1>(.*?)</h1>};

    my $header  = header ($title, $week);
    my $trailer = trailer ($week);
    open my $fh, ">", $html_file or die "open $html_file: $!";
    print $fh <<~ "--";
        <html>
        $header
        $html_text
        $trailer
        </html>
        --
    close $fh or die "close $html_file: $!";
}

__END__
