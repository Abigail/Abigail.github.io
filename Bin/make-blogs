#!/opt/perl/bin/perl

use 5.028;

use strict;
use warnings;
no  warnings 'syntax';

use experimental 'signatures';
use experimental 'lexical_subs';

use Text::Markdown qw [markdown];

my $POLYFILL_URL   = "https://polyfill.io/v3/polyfill.min.js?features=es6";
my $MATHJAX_URL    = "https://cdn.jsdelivr.net/npm/mathjax@3/" .
                             "es5/tex-mml-chtml.js";
my $CHART_URL      = "https://cdn.jsdelivr.net/npm/chart.js";

my $HOME           = $ENV {HOME};
my $TOP_DIR        = "$HOME/GitHub/Blogs";
my $SRC_DIR        = "Src";
my $HTML_DIR       = "HTML";
my $DIR_PWC        = "Perl-Weekly-Challenge";
my $DIR_FC         = "Feature-Compare";
my $DIR_ADVENT     = "AdventOfCode";

my $TYPE_PWC       = 1;
my $TYPE_FC        = $TYPE_PWC + 1;
my $TYPE_ADVENT    = $TYPE_FC  + 1;

my $TYPE2DIR       = {
    $TYPE_PWC       =>  $DIR_PWC,
    $TYPE_FC        =>  $DIR_FC,
    $TYPE_ADVENT    =>  $DIR_ADVENT,
};

my $TYPE2NAV       = {
    $TYPE_PWC       =>  "nav_weekly_challenge",
    $TYPE_FC        =>  "nav_feature_compare",
    $TYPE_ADVENT    =>  "nav_advent_of_code",
};


my $STYLE_DIR      = "Styles";
my $JAVASCRIPT_DIR = "JavaScript";
my @SCRIPTS        = qw [jquery navigation];
my $FULL_HTML_DIR  = "$TOP_DIR/$HTML_DIR";
my $FULL_SRC_DIR   = "$TOP_DIR/$SRC_DIR";
my @FONTS          = map {s/ /+/r} ("Lobster Two",
                                    "Source Code Pro",
                                    "Pinyon Script",
                                    'Sorts Mill Goudy:ital@1',);
my $FONTS          = join "&" => map {"family=$_"} @FONTS;
my $FONT_URL       = "https://fonts.googleapis.com/css2?$FONTS&display=swap";

my $PERLFUNC_URL   = "https://perldoc.perl.org/perlfunc";
my $PERLDOC_URL    = "https://perldoc.perl.org";
my $METACPAN_URL   = "https://metacpan.org/pod";
my $GAWK_URL       = "https://www.gnu.org/software/gawk/manual/gawk.html";
my $BASH_URL       = "https://www.gnu.org/software/bash/manual/bash.html";
my $FREEBSD_URL    = "https://www.freebsd.org/cgi/man.cgi?" .
                                                 "apropos=0&sektion=%d&query";
my $PYTHON_URL     = "https://docs.python.org/3/library/functions.html";
my $NODE_URL       = "https://developer.mozilla.org/en-US/docs/Web/" .
                                                   "JavaScript/Reference";
my $RUBY_URL       = "https://apidock.com/ruby";
my $GO_URL         = "https://pkg.go.dev";
my $WIKI_URL       = "https://en.wikipedia.org/wiki";
my $OEIS_URL       = "https://oeis.org";
my $MATH_WORLD_URL = "https://mathworld.wolfram.com";

my $GITHUB_URL     = "https://github.com";
my $GITHUB_USER    = "Abigail";
my $GITHUB_REPO    = "perlweeklychallenge-club";
my $GITHUB_BRANCH  = "master";
my $CHALLENGE_USER = "abigail";

my %LANGUAGE_INFO = (
    AWK           => {},
   "GNU AWK"      => {name => "awk",    ext => "gawk"},
    Bash          => {                  ext =>   "sh"},
    Basic         => {                  ext =>  "bas"},
    bc            => {},
   "Befunge-93"   => {                  ext => "bf93"},
    C             => {},
    Cobol         => {                  ext =>   "cb"},
    Csh           => {                  ext =>  "csh"},
    Erlang        => {                  ext =>  "erl"},
    Forth         => {                  ext =>   "fs"},
    Fortran       => {                  ext =>  "f90"},
    Go            => {},
    Java          => {},
    Lua           => {},
    m4            => {},
   "Node.js"      => {name => "node",   ext =>   "js"},
    OCaml         => {                  ext =>   "ml"},
    Pascal        => {                  ext =>    "p"},
   "Free Pascal"  => {name => "pascal", ext =>    "p"},
    Perl          => {                  ext =>   "pl"},
    PHP           => {},
    PostScript    => {                  ext  =>  "ps"},
    Python        => {                  ext =>   "py"},
    R             => {},
    Rexx          => {},
    Ruby          => {                  ext =>   "rb"},
    Scheme        => {                  ext =>  "scm"},
    sed           => {},
    SQL           => {},
    Tcl           => {},
);

my %LINK_GROUP; init_link_group ();

chdir $TOP_DIR or die "chdir: $!";


sub header ($title, $directives) {
    #
    # Return the header of the HTML page
    #
    my $dir  = $$directives {dir};
    my $base = $$directives {base};
    my $type = $$directives {type};

    my $up   = $type eq $TYPE_ADVENT ? "../../.." : "../..";

    my $styles = join "\n" =>
        map  {"<link rel = 'stylesheet' href = '$up/$_'>"}
        grep {-f}
        map  {"$STYLE_DIR/$_.css"} "main",
                                   "$dir/main",
                                   "$dir/$base";

    my @scripts = sort glob "$JAVASCRIPT_DIR/$dir/$base*.js";
    my $scripts = join "\n" =>
        map  {"<script src = '$up/$_'></script>"}
        @scripts,
        grep {-f}
        map  {"$JAVASCRIPT_DIR/$_.js"}
               @SCRIPTS,
               $$TYPE2NAV {$type},
               split /,\s*/ => ($$directives {script} // "");

    my $chart_js = "";
       $chart_js = "<script id = 'chart-script' async src = '$CHART_URL'>" .
                  "</script>" if $$directives {has_canvas};

    return <<~ "--" =~ s/^\s*\n//gmr;
        <head>
        <title>$title</title>
        <script src = "$POLYFILL_URL"></script>
        <script id = "MathJax-script" async src = "$MATHJAX_URL"></script>
        $chart_js
        $scripts
        <link rel = 'preconnect' href = 'https://fonts.gstatic.com'>
        <link rel = 'stylesheet' href = '$FONT_URL'>
        $styles
        </head>
        --
}

#
# Create a link to the full program on GitHub
#
sub github_link ($language, $info = "", $directives = {}) {
    my $link;
    my $lang_info = $LANGUAGE_INFO {$language};
    my  %info;
    if ($info) {
        my @chunks = split /;\s*/ => $info;
        %info = map {split /\s*=\s*/ => $_, 2} @chunks;
    }

    if ($$directives {type} == $TYPE_ADVENT) {
        $link = sprintf "%s/%s/AdventofCode%4d/blob/%s/Day_%02d/solution%s.%s"
                    =>  $GITHUB_URL,
                        $GITHUB_USER,
                        $$directives {year},
                        $GITHUB_BRANCH,
                        $$directives {day},
                        $info {part_nr} ? "-" . $info {part_nr} : "",
                        $$lang_info {ext}  || lc $language,
    }
    else {
        my ($week_nr, $part_nr) = split /-/ => $$directives {week};
        $link = sprintf "%s/%s/%s/blob/%s/challenge-%03d/%s/%s/ch-%d.%s" =>
                         $GITHUB_URL,
                         $GITHUB_USER,
                         $GITHUB_REPO,
                         $GITHUB_BRANCH,
                         $week_nr,
                         $CHALLENGE_USER,
                         $$lang_info {name} || lc $language,
                         $info {part_nr}    || $part_nr,
                         $$lang_info {ext}  || lc $language;
    }
    $link;
}

sub full_program ($language, $tag, $info, $directives) {
    my $link = github_link (($tag || $language) =~ s/_/ /gr,
                             $info, $directives);
    return "Find the [full program]($link) on [GitHub]($GITHUB_URL).\n";
}



#
# For patterns of the form [...](#...), this method is called,
# and the result is substituted will be placed inside the ().
#
sub make_link (%args) {
    my $anchor   = $args {anchor};
    my $link     = $args {link};
    my $week     = $args {week};
    my $language = $args {language};
    my $url;
    if ($LANGUAGE_INFO {$language} && $link !~ /^#/) {
        # Remove backtics
        $anchor =~ s/^`//;
        $anchor =~ s/`$//;
        if ($language eq "Perl") {
            if (!$link) {
                #
                # Does the link point to a module?
                #
                $url = $anchor =~ /::/ ? $METACPAN_URL . "/" . $anchor
                                       : $PERLFUNC_URL . "#" . $anchor;
            }
            elsif ($link =~ /^op:/p) {
                $url = $PERLDOC_URL . "/perlop#" . ${^POSTMATCH}
            }
            elsif ($link =~ /doc:/p) {
                $url = $PERLDOC_URL . "/" . ${^POSTMATCH}
            }
        }
        elsif ($language eq "GNU AWK" || $language eq "AWK") {
            $url = $GAWK_URL . "#" . ($link || $LINK_GROUP {AWK} {$anchor}
                                            || "");
        }
        elsif ($language eq "Bash") {
            $url = $BASH_URL . "#" . ($link || $LINK_GROUP {Bash} {$anchor}
                                            || "");
        }
        elsif ($language eq "C") {
            if (!$link || $link =~ /^[0-9]$/) {
                $url = sprintf $FREEBSD_URL . "=" . $anchor => $link || 0;
            }
        }
        elsif ($language eq "Go") {
            if (!$link && $LINK_GROUP {Go} {$anchor}) {
                $url = $GO_URL . "/" . $LINK_GROUP {Go} {$anchor}
                               . "#" . $anchor;
            }
        }
        elsif ($language eq "Python") {
            if (!$link) {
                $url = $PYTHON_URL . "#" . $anchor;
            }
        }
        elsif ($language eq "Node.js") {
            if ($link) {
                $url = $NODE_URL . "/$link";
            }
            else {
                if (my $chapter = $LINK_GROUP {$language} {$anchor}) {
                    $url = $NODE_URL . "/$chapter/$anchor";
                }
            }
        }
        elsif ($language eq "Ruby") {
            if ($link) {
                $url  = $RUBY_URL . "/$link";
                $url .= "/$anchor" unless $link =~ m{/};
            }
        }
    }
    $link =~ s/^#//;
    if (!$url) {
        if ($link =~ /(?<where>[^:]+)(?::(?<what>.*))?$/) {
            my $where = $+ {where};
            my $what  = $+ {what};
            if (!$what) {
                $what = $anchor =~ s/\s+/_/gr;
            }
            if    ($where eq "wiki")      {$url = $WIKI_URL . "/" . $what}
            elsif ($where eq "oeis")      {$url = $OEIS_URL . "/" . $what}
            elsif ($where eq "mathworld") {$url = $MATH_WORLD_URL .
                                                  "/" . $what . ".html"}
            elsif ($where eq "meta")      {$url = $METACPAN_URL . "/" . $what}
        }
    }
    if (!$url && $link eq "github") {
        $url = github_link ($anchor, $week);
    }
    $url //= "#$link";

    $url;
}

my $link_pattern = qr {\[    (?<anchor> [^]]*) \]
                       \( \# (?<link>   [^)]*) \)}x;

sub process_section ($section, $language, $directives) {
    my $week = $$directives {week};

    #
    # Default to Perl
    #
    $language =~ s/^(?:Very\s+)Evil\s+//i;
    if (!$language || !$LANGUAGE_INFO {$language}) {
        $language = "Perl";
    }
    #
    # Step one, find the links starting with a #, and process them.
    #
    $section =~ s {$link_pattern}
                  {"[" . $+ {anchor} . "]" .
                   "(" . make_link (anchor   => $+ {anchor},
                                    link     => $+ {link},
                                    week     => $week,
                                    language => $language) . ")"}ge;

    #
    # Replace any lines with FULL_PROGRAM to a section pointing
    # to the file on GitHub.
    #
    $section =~ s {^FULL_PROGRAM(?::(?<tag>[^\s;]+))?(?:;(?<info>\S+))?\s*$}
                  {full_program ($language, $+ {tag}, $+ {info},
                                 $directives)}gem;

    #
    # Process MathJax delimiters
    #
    $section =~ s/(?<!\\)(\\[]()[])/\\$1/g;
    $section =~ s {(\\ \\ \( .*? \\ \\ \))}
                  {<span class = 'latex-inline'>$1</span>}xg;
    $section =~ s {(\\ \\ \[ .*? \\ \\ \])}
                  {<span class = 'latex-display'>$1</span>}xg;

    #
    # Turn a double dash into an &mdash -- except inside a pre-
    # formatted section.
    #
    $section =~ s {("--"|'--'|^\h*--\h*$|^    .*)|(?<!-)--(?!-)}
                  {$1 || "&mdash;"}gme;

    $section . "\n";
}

#
# Given a piece of text, turn it into an Markdown blockquote
#
sub block_quote ($text) {$text =~ s/^/> /mgr}

#
# Given a piece of text, turn it into an Markdown blockquote;
# Remove any HTML escape sequences.
#
sub code_block ($text) {
    $text =~ s/^/    /mgr
          =~ s/&lt;/</gr
          =~ s/&gt;/>/gr
          =~ s/&quot;/"/gr
          =~ s/&amp;/&/gr
}

#
# Process a block of text which should turn into an HTML table.
#
# For now, rows are separated by \\, columns by && (like LaTeX).
# Table level attributes can be given with a leading {..} block.
# Cell level attributes can be given with a leading {..} block in the cell.
#
sub table ($text) {
    my $skip = qr [\s* (?: <!-- (?:[^-]+ | -(?!-))* --> \s*)* ]x;
    my $attributes = "markdown = '1'";
    if ($text =~ s/^\s*\{\s*([^}]+)\}\s*\n//) {
        $attributes .= " " . $1;
    }

    my $out  = "<table $attributes>\n";

    my @rows = split /\s*\\\\\s*/ => $text;
    my %skip;
    foreach my $rc (keys @rows) {
        my $row = $rows [$rc];
        $out .= "  <tr class = 'row-$rc' markdown = '1'>\n";
        my @cells = split /\s*&(?![A-Za-z0-9#])\s*/ => $row, -1;
        my $cc = 0;
        foreach my $cell (@cells) {
            #
            # Grab a block of configuration from the cell,
            # if it exists.
            #
            my $attributes = "markdown = '1'";
            my $cc_inc     = 1;
            my $td         = "td";
            my $class      = "";
            my $rs         = 1;
            if ($cell =~ s/^$skip\{\s*([^}]+)\}\s*//) {
                my %config = map {split /\s*=\s*/, $_, 2}
                                  split /\s*;\s*/ => $1;
                if ((my $rowspan = $config {rs} || 0) > 1) {
                    $attributes .= " rowspan = '$rowspan'";
                    $rs = $rowspan;
                }
                if ((my $colspan = $config {cs} || 0) > 1) {
                    $attributes .= " colspan = '$colspan'";
                    $cc_inc = $colspan;
                }
                $td = "th" if $config {th};
                $class = $config {class} // "";
            }

            $cc ++ while $skip {$rc} {$cc};

            $out .= "    <$td class = 'cell-$rc-$cc col-$cc $class'" .
                            " $attributes>$cell</td>\n";

            #
            # Keep track of cells which are to be "skipped", because
            # they're covered due to a rowspan earlier.
            #
            if ($rs > 1) {
                for my $row_offset (2 .. $rs) {
                    for my $col_offset (1 .. $cc_inc) {
                        printf "{%d}{%d} = 1\n", $rc + $row_offset - 1,
                                                 $cc + $col_offset - 1;
                        $skip {$rc + $row_offset - 1}
                              {$cc + $col_offset - 1} 
                              = 1;
                    }
                }
            }
            $cc += $cc_inc;
        }
        $out .= "  </tr>\n";
    }
    $out .= "</table>\n";

    $out;
}



sub pre_process ($text, $directives) {
    state $lang_pat = join "|" => map {quotemeta $_} keys %LANGUAGE_INFO;

    my $out = "";

    #
    # Scan for directives, which are of the format
    #
    #   <!-- %% directive        --> or
    #   <!-- %% directive: value -->
    #

    while ($text =~ s/^\s*<!--\s*%%\s*(\S+)(?:\s*:\s*(.*\S))?\s*-->\s*\n//m) {
        $$directives {$1} = $2 // 1;
    }

    my @tokens = (["\Q~~~~",  "\Q~~~~",  \&code_block],
                  ["\Q>>>>",  "\Q<<<<",  \&block_quote],
                  ["\Q|====", "\Q====|", \&table],);
    my $pat = join '|' => map {@$_ [0, 1]} @tokens;

    TOKEN: {
        my $changed;
        foreach my $entry (@tokens) {
            my ($start, $end, $call_back) = @$entry;
            $changed ++ if $text =~ s {^$start \h* \n
                                        ((?:^(?!$pat) \N* \n)*)
                                        $end \h* \n}
                                      {$call_back -> ($1)}xem;
        }
        redo if $changed;
    }

    #
    # Iterate over the lines. Use a state to determine what the current
    # language is (### <LANG>).
    #
    my $language     = "";
    my $preformatted =  0;
    my $section      = "";

    foreach my $line (split /\n/ => $text) {
        if ($line =~ /^###\s+(?<header>.*)/) {
            if ($section) {
                $out .= process_section ($section, $language, $directives);
                $section = "";
            }
            $language = $+ {header};
            $out .= $line . "\n";
            next;
        }
        $section .= $line . "\n";
    }
    if ($section) {
        $out .= process_section ($section, $language, $directives);
    }

    extract_ref_links ($text);

    return $out;
}

#
# In some cases, markdown doesn't process [link][ref] // [ref]: URL.
# So, we will handle them ourselves.
#
{
    my %link_ref;
    sub extract_ref_links ($text) {
        while ($text =~ /\[([^]]+)\]:\s*(\S+)/g) {
            $link_ref {$1} = $2;
        }
    }
    sub create_ref_links ($text) {
        my $refs = join "|" => keys %link_ref;
        $text =~ s {\[([^]]+)\]\[($refs)\]}
                   {<a href = '$link_ref{$2}'>$1</a>}gr;
    }
}


sub by_line ($directives) {
    my $up = $$directives {type} == $TYPE_ADVENT ? "../../.." : "../..";
    <<~ "--"
    <div class = "byline">
    by Abigail<br>
    <img src = "$up/Images/jan_sluiters.jpg">
    </div>
    --
}

sub post_process ($text, $directives) {
    #
    # Add a line after the first <h1>
    #
    $text =~ s{</h1>.*\K}{by_line ($directives)}e;

    #
    # Turn sections between headers into divs
    #
    $text =~ s {(</h[1-6]>\s*)(<p>.*?\S)(\s*(?:<h[1-6]>|</body>))}
               {$1<div class = "section">\n$2\n</div>$3}gs;

    #
    # Handle !class (and friends)
    #
    $text =~ s {^((?:<p>)?)(!/proof</p>)}
               {<span class = "qed"></span>\n$1$2}gm;
           #   {<span class = "qed">&#x220E;</span>\n$1$2}gm;
    $text =~ s {^<p>!(\w+)\h*$} {<div class = "$1 headed-div"><br><p>}gm;
    $text =~ s {^(?:<p>)?!/\w*</p>\h*$} {</p></div>}gm;

    #
    # Remove any empty paragraphs/divs
    #
    $text =~ s {<(p|div)>\s*</\g{1}>} {}gi;

    #
    # Create ref links not processed
    #
    $text = create_ref_links ($text);

    $text;
}

sub trailer ($week) {<<~ "--"}
    <hr id = 'last-line'>
    <div class = 'trailer'>
    <p class = 'prev'><a class = "prev" href = "">&#x261C;</a></p>
    <p class = 'issue'>Please leave any comments as a
      <a href = 'https://github.com/Abigail/Abigail.github.io/issues'
         title = 'GitHub issue'>GitHub issue</a>.
    <p class = 'next'><a class = "next" href = "">&#x261E;</a></p>
    </div>
    --


sub init_link_group () {
    my @entries = (
        [qw [AWK String-Functions
                 asort asorti gensub gsub index length match patsplit split
                 sprintf strtonum sub substr tolower toupper]],
        [qw [Bash Bash-Builtins
                  alias bind builtin caller command declare echo enable
                  help let local logout mapfile printf read readarray
                  typeset ulimit unalias]],
        [qw [Go strings
                  TrimRight TrimRightFunc TrimSpace TrimSuffix]],
        [qw [Go builtin
                  append cap close complex copy delete imag len make
                  new panic print println real recover]],
        [qw [Node.js Global_Objects/String
                  replace trim match length]],
        [qw [Node.js Global_Objects/Array
                  reduce]],
    );

    foreach my $entry (@entries) {
        my $language = shift @$entry;
        my $anchor   = shift @$entry;
        foreach my $function (@$entry) {
            $LINK_GROUP {$language} {$function} = $anchor;
        }
    }
}



#
# Main program
#
die "$0 source-file ..." unless @ARGV;
my @todo;
foreach my $arg (@ARGV) {
    my ($type, $base);
    if ($arg =~ /^[0-9]{3}-[0-9]$/) {
        $type = $TYPE_PWC;
        $base  = "week-$arg";
    }
    elsif ($arg =~ /^(20[0-9]{2})(?:-12)?-([0-9]{2})$/) {
        $type = $TYPE_ADVENT;
        $base = "$1/day-$2";
    }
    elsif ($arg =~ /^fc-(.*)/) {
        $type = $TYPE_FC;
        $base = "$1";
    }
    else {
        my $arg = $arg =~ s!^$SRC_DIR/!!r;
        foreach my $t (keys %$TYPE2DIR) {
            my $dir = $$TYPE2DIR {$t};
            if (index ($arg, $dir) == 0) {
                $type = $t;
                $base = (substr $arg, 1 + length $dir) =~ s/\.md$//r;
                last;
            }
        }

        die "Don't know what to do with $arg" unless $type && $base;
    }
    push @todo => [$type, $$TYPE2DIR {$type}, $base];
}

foreach my $todo (@todo) {
    my ($type, $dir, $base) = @$todo;
    my $source_file = "$SRC_DIR/$dir/$base.md";
    my $html_file   = "$HTML_DIR/$dir/$base.html";

    my $week = $type == $TYPE_PWC    && $base =~ /^week-(.*)/  ? $1 : 0;
    my $year = $type == $TYPE_ADVENT && $base =~ m{^([0-9]+)/} ? $1 : 0;
    my $day  = $type == $TYPE_ADVENT && $base =~ m{/day-(.*)}  ? $1 : 0;

    my $source_text = `cat $source_file`;
    my $directives  = {};
    $$directives {week} = $week;
    $$directives {base} = $base;
    $$directives {type} = $type;
    $$directives {dir}  = $dir;
    $$directives {year} = $year;
    $$directives {day}  = $day;

    $source_text = pre_process $source_text, $directives;

    my $html_text   = markdown ($source_text => {
        empty_element_suffix => ">"
    });
    $html_text = "<body>$html_text";

    #
    # Add a newline before the closing </div>
    #
    $html_text =~ s{</div>\s*$}{\n</div>};

    $html_text = post_process ($html_text, $directives);

    my ($title)     = $html_text   =~ m{<h1>(.*?)</h1>};

    $$directives {has_canvas} = 1 if $source_text =~ /^<canvas/m;
    $$directives {week}       = $week;

    my $header  = header ($title, $directives);
    my $trailer = trailer ($week);
    open my $fh, ">", $html_file or die "open $html_file: $!";
    print $fh <<~ "--";
        <html>
        $header
        $html_text
        $trailer
        </body>
        </html>
        --
    close $fh or die "close $html_file: $!";
}



__END__
